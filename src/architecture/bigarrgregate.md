---
title: DDD诊所病例 —— 聚合肥大症
---
# **DDD诊所病例 ------ 聚合肥大症**
【按】"DDD诊所"是Thoughtworks
DDD社区的一项活动，旨在通过分析和解答对同事们在实施DDD过程中遇到的问题，共同提高开发水平。我们整理了一些典型案例供大家参考。在适当的时候，我们也会考虑接受外部案例将诊所这一形式对外部开放。
就诊日期：2022年6月8日
患者：某DevOps平台流水线部分
诊金：0元（免费义诊）

## 【患者主诉】
### 背景
在某DevOps平台开发过程中，有一个设计持续交付流水线的功能，用户可以在页面设计整个流水线，完成以下功能：
1.  给流水线设计前置触发条件。主要有两种触发方式，一种是某个代码仓库提交触发，另一种是定时任务。这些触发条件的数量没有限制。
2.  给流水线设计不同的阶段，诸如开发阶段、测试阶段等。对于每个阶段，用户可以设置不同的步骤，例如Checkout、编译、构建镜像和部署等。
3.  可以选择给阶段设置质量门禁。门禁具体参数诸如单元测试覆盖率大于80%等。这些门禁指标可以在质量门禁管理功能中设置。在流水线执行时，如果不满足门禁指标，会阻止流水线进入下一个阶段。

![](media/image1.png){width="6.5in" height="3.9722222222222223in"}
*持续交付流水线界面原型*

项目架构师收到需求后，根据需求设计了如下领域模型：

![](media/image5.png){width="6.5in" height="5.333333333333333in"}
*持续交付流水线领域模型*

这个模型的设计目的是为了方便用户在界面上完成一系列操作，比如检查代码质量、编译代码、构建镜像和部署等，这些操作在技术上被看做一个整体。所有这些操作都被组织在一个称为"流水线"的聚合体中，其中包括质量门禁、不同的阶段和触发规则等。这种设计可以帮助用户快速完成复杂的操作，同时也可以使代码更加整洁和易于维护。
注：上图中的\<\<map from\>\>
是一种自定义的衍型，意味着该对象映射自其他上下文。
这个时候，一些问题也出现了：

### 引发问题
#### 1. 认知负载上升
这个聚合包含了7个实体（不包括抽象类），每个实体都有自己的属性需要维护，因此这个聚合的认知负载相对较大。此外，该部分业务需要集成不同的外部依赖系统，例如依赖Sonar用于实现质量门禁、依赖定时任务组件用于定时任务触发器、以及依赖GitLab或GitHub等代码托管平台用于代码提交触发器。尽管可以通过使用Repository模式和依赖倒置原则将功能与实现分离，但是开发或维护人员仍然需要掌握相关知识。如果某个人接手了这部分功能（例如修改质量门禁相关功能），那么他或她基本上就需要了解整个系统的运作方式。
#### 2. 部分可用性的可能性被牺牲
这一个功能集成了这么多三方系统，它们在一个聚合的基础上需要同步的进行操作。由于这些功能中的任何一部分不可用时，整个功能都将收到影响，因此难以做到部分可用性。例如，当Sonar服务暂时不可用时，代码触发和阶段维护也会同时不可用。假设后续需求变更，需求方提出Sonar不可用的情况下，要提示质量门禁设置失败，其他部分要照常保存的时候，必然会破坏整个聚合的一致性边界。不幸的是,在不知不觉中，我们设计了一个分布式单体。

**分布式单体架构** ：
是一种同时具备分布式和单体的劣势的一种架构。一方面，它没有分布式系统的高可用性、弹性扩容等优势，另一方面，它也不具备单体架构实现ACID强一致性方面的便利，通常出现在未经良好设计的微服务风格的分布式软件中。
#### 3. 牺牲了性能和并发性
当前的交互设计是一次性提交对流水线的所有变更。实际上，用户在每次修改时，不一定需要同时修改质量门禁、阶段、触发规则等所有的部分。然而由于聚合模式的特点，我们每次都需要对整个聚合的所有实体进行整存整取。即使用户只想修改其中一部分（如"触发规则"），我们仍需要更新名为"流水线"的聚合的整个7个模型，这将导致巨大的性能浪费。此外，如果两个用户同时操作业务上互不影响的两部分如"触发规则"和"质量门禁"时，会相互冲突，有一个用户要被提示"设计已变更，修改失败"，降低了系统的吞吐量。

## 【诊断】
初步诊断，**患者的病情主要是聚合肥大症**，即将聚合设计不合理，导致聚合过大。在DDD实践中，合理划分聚合是个比较有挑战的问题。
### 聚合肥大症的征兆
在DDD的落地实践过程中，聚合的大小经常被描述为一个不可言说的知识。很多时候，凭经验和感觉会导致比较差的设计。然而，在实践中，识别大聚合仍有迹可循，一般来说，出现了这三种情况时，就需要警惕聚合肥大症：
#### 1. 宽聚合
一个聚合聚合了多个同级实体，一个"父亲"多个 "儿子"。如图所示：一旦超过三就有大聚合的风险。
#### 2. 深聚合
聚合根聚合了一个实体，这个实体又是另一个实体的聚合如此反复 例如"父亲""儿子" "孙子" "重孙 "。当层级达到三层时，就存在大聚合的风险。
#### 3. 胖聚合
尽管结构简单，但实体对象实例多。如果在业务场景中，一个聚合的大量实体类的实例非常多的情况频繁出现，那么这里也存在大聚合的风险。
![](media/image3.png){width="6.5in" height="2.611111111111111in"}
*聚合肥大的三个征兆*

### 聚合肥大症的症状
聚合肥大症会导致一系列问题，如案例所述，主要包括以下三点：
#### 1. 认知负载上升
大聚合会增加代码复杂度，从而提升认知负载。在做软件设计时，我们应该上一个聚合成单尽量少的责任，以降低代码的复杂度，进而提高软件的可维护性。然而，大聚合通常意味着包含大量的业务知识，因此难以维护。
#### 2. 部分可用性的可能性被牺牲
在聚合模式下，整个聚合的各个部分相互关联，如果聚合过于肥大，说明其包含了过多的业务部分，一旦部分出现故障，整个聚合都可能收到影响，从而导致不可用。
#### 3. 性能问题
过大的聚合会导致许多不必要的的性能浪费。三种模式的肥大聚合都包含比较多的对象，因此读取和存储的成本都相对较高。

## 【病理分析】
出现大聚合的问题，很可能源于聚合划分的不合理。为了解决这个问题，我们可以回顾DDD原书中关于聚合模式的定义，以了解如何合理划分聚合。
### 怎样合理的划分聚合
在《领域驱动设计：软件核心复杂性应对知道》一书中，聚合的定义如下：
在具有复杂关联的模型中，要想保证对象更改的一致性是很困难的。需要维护适用于密切相关的对象组的Invariant，而不仅仅是离散的对象。然而，过于谨慎的锁定机制又会导致多个用户之间毫无意义地互相干扰，从而使系统不可用。
我们应该将 ENTITY和 VALUE OBJECT分 门 别 类地 聚集 到 AGGREGATE中，并定义每个AGGREGATE的边界。在每个AGGREGATE中，选择一个ENTITY作为根，并通过根来控制对边界内其他对象的所有访问。只允许外部对象保持对根的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。由于根控制访问，因此不能绕过它来修改内部对象。这种设计有利于确保AGGREGATE中的对象满足所有固定规则，也可以确保在任何状态变化时AGGREGATE作为一个整体满足固定规则。
\-\-\-\--《领域驱动设计：软件核心复杂性应对之道》

根据**聚合模式**的定义，我们可以得出判断两个实体（Entity）是否属于一个聚合的依据，需要把握两个条件：
#### 存在整体部分关系
当某个Entity是另一个Entity的部分时，称为**整体部分关系**。例如：

学生是班级的一个部分；

车门是汽车的一个部分；

人体的器官是人体的一个部分；

公司是企业的一个部分；

等等。

当然，这种关系也可以是多重的，例如：

学生是班级的一个部分，班级又是学校的一个部分；

车门是汽车的一个部分，汽车又是公司的一个部分；

人体的器官是人体的一个部分，人体又是家庭的一个部分；

等等。

#### 存在整体生命周期关系
当某个Entity的生命周期与另一个Entity相关联时，称为**整体生命周期关系**。例如：

学生的入学时间与班级的开班时间相关联；

车门的使用寿命与汽车的使用寿命相关联；

人体器官的寿命与人体的寿命相关联；

公司的成立时间与企业的成立时间相关联；

等等。

The tires on a car are part of the car.

-   学生是班级不可或缺的一部分。

- 订单行是订单的一部分

#### 实体之间存在变更时需要遵守的固定规则（Invariants）
##### 固定规则的定义
固定规则或称为不变量不变式，来自契约式设计。
In computer science, an invariant is a logical assertion that is always
held to be true during a certain phase of execution of a computer
program. For example, a loop invariant is a condition that is true at
the beginning and the end of every iteration of a
loop.在计算机科学中，不变量是指在计算机程序执行的某一阶段始终为真的逻辑论断。例如，循环不变量是一个条件，在一个循环的每个迭代开始和结束时都是真的。

\-\-- wiki
[[https://en.wikipedia.org/wiki/Invariant_(mathematics)]{.underline}](https://en.wikipedia.org/wiki/Invariant_(mathematics))

##### 在划分聚合时，我们关注的是一些因为业务原因所约束的固定规则。这些规则通常是通过与业务人员讨论得出的，比如："A更新的时候，会不会引起B的某个属性的更新"，"这种更新如果两个实体暂时不一致会不会产生什么难以承受的业务后果"等问题。

例如，在订单系统中，假设需求是整个订单的总价
等于订单行的总价之和，且总价必须小于3000（左图）。在这种情况下，订单与订单行之间就存在固定规则因此，可以把他们放在同一个聚合里，并通过整存整取来维护这个固定规则。然而，如果业务场景是订单仅仅作为订单行的分组，用户需要按照订单行逐一结账（右图）那么订单和订单行就无需划分成一个聚合。

![](media/image4.png){width="6.5in" height="5.430555555555555in"}

固定规则是划分聚合的重要条件。

##### 划分聚合时不需要考虑的其他情况

下的固定规则

部分固定规则是由于技术实现所约束的，比如数据库ID不重复、订单编号唯一等。这些规则通常是全局的，它们在整个系统范围内都需要遵循。然而，由于这些全局性的固定规则通常与特定的业务逻辑无关，因此在划分聚合时，它们一般不作为决定因素。

### 大聚合都必须拆小么？
尽管利用业务固定规则通常能够确定较小的业务一致性边界，进而得出比较合适的聚合规模。然而，并不是所有的业务都适应这一原则。在一些比较大的订货订单或者其他比较复杂的业务场景中，大聚合可能是不可避免的。在这种情况下，需要权衡是使用大聚合带来的成本是否可以接受，从而决定是否按照聚合模式实现代码。因为聚合本质上是一种设计模式，而非万能的解决方案，在不合适的场景下强行应用聚合可能会导致收益不成正比。

聚合模式是为了解决复杂业务中的一致性问题，将具备固定规则的一组对象整存整取的一种方案。采用聚合模式的优点在于是一致性约束的保证，代价就是整存整取带来的性能损失。

## 【药方】
在案例中，尽管流水线各部分之间存在整体部分关系，但是通过分析业务，我们梳理出的以下固定规则：
1.  阶段内的步骤之间存在严格的顺序依赖，因为下一个步骤通常依赖上一个步骤的产出物。因此,存在一个固定规则：某个步骤的执行顺序必须按照阶段的步骤列表中的顺序。
2.  阶段质量门禁和阶段质量门禁项之间存在固定规则，即当在门禁项发生变更时，门禁版本也必须随之更新门禁的版本有一定的业务含义（例如，门禁版本更新需要在界面上显式提示）。

![](media/image4.png){width="6.5in" height="5.430555555555555in"}

*整改后的聚合*
因此得出了如上述的整改方案。在这个方案中，原本的一个聚合被拆分为了四个聚合，每个聚合都只包含较少的实体。这样一来，聚合规模变得较小，取得了比较好的性能和业务一致性的权衡。

## 【总结】
在DDD实践中，聚合的划分确实是一个难以掌握的问题。聚合本身是一种有代价的模式，不合理的聚合划分可能导致严重的问题，从而引发一系列疑问，例如"为什么使用DDD后仍然遇到各种问题？"聚合肥大症是聚合划分中的一种常见问题，当模型中出现宽聚合、深聚合或胖聚合时，我们需要警惕聚合肥大症及其带来的难以维护、牺牲可用性和性能损失等问题。
要解决这个问题，我们需要回顾聚合解决的核心问题：如何维护对象之间的固定规则。再次考虑聚合的划分时，需要满足两个条件：整体-部分关系和实体变更时需要遵循的固定规则。当使用聚合模式的代价过大时，可以考虑其他方法来实现，例如通过锁机制锁定需要维护一致性的对象方法。
总之，在实践DDD时，我们应该关注聚合的划分和优化，以确保在保持业务一致性和完整性的同时，避免因聚合肥大导致的性能和可用性问题。在面临聚合模式代价过大的情况时，可以灵活选择其他方法来实现业务一致性和完整性。